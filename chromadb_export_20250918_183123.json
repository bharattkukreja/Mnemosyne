[
  {
    "id": "5bafda14-ea13-4999-9cd7-eff83075048a",
    "content": "Use React for frontend | React chosen as the frontend framework for the project",
    "metadata": {
      "type": "decision",
      "conversation_id": "",
      "developer_id": "",
      "timestamp": "2025-09-17T19:24:17.539752",
      "tags": "[\"frontend\", \"framework\", \"react\"]",
      "files": "[]"
    }
  },
  {
    "id": "926da1a2-384c-4842-9148-bd81981be4db",
    "content": "Use Rails for frontend work | Changed from React to Rails for frontend development",
    "metadata": {
      "conversation_id": "",
      "tags": "[\"frontend\", \"framework\", \"rails\", \"architecture-change\"]",
      "timestamp": "2025-09-17T19:38:20.286595",
      "type": "decision",
      "files": "[]",
      "developer_id": ""
    }
  },
  {
    "id": "98b096af-ab23-4549-8e9a-6eb67f3d2a45",
    "content": "Created comprehensive Python Hello World examples | Built multiple Hello World implementations in Python to demonstrate different programming paradigms: basic print, functions with parameters, user interaction, and object-oriented approach. This provides a good foundation for Python learning.",
    "metadata": {
      "developer_id": "",
      "type": "decision",
      "conversation_id": "",
      "files": "[\"python_hello_world.py\"]",
      "tags": "[\"python\", \"hello-world\", \"beginner\", \"examples\", \"learning\"]",
      "timestamp": "2025-09-18T11:07:02.902129"
    }
  },
  {
    "id": "8b553b37-17fd-4466-9e4f-c818e9ba4a53",
    "content": "Modified Python example to use \"Foo\" and \"Bar\" instead of \"Hello\" and \"World\" | User requested to rename \"Hello\" to \"Foo\" and \"World\" to \"Bar\" throughout the Python code. Updated all instances including function names, default parameters, comments, and string literals to reflect these changes.",
    "metadata": {
      "type": "decision",
      "developer_id": "",
      "timestamp": "2025-09-18T11:07:52.638273",
      "conversation_id": "",
      "files": "[\"python_hello_world.py\"]",
      "tags": "[\"python\", \"modification\", \"foo-bar\", \"refactoring\"]"
    }
  },
  {
    "id": "0d8ce898-3a01-43f7-9c9e-5a05dac49528",
    "content": "Converted simple Python Hello World into a functional MCP server | Transformed the basic Hello World example into a complete MCP (Model Context Protocol) server implementation. The server includes tools for greetings and stats, resources for server information, and proper async handlers. This provides a practical foundation for building MCP servers.",
    "metadata": {
      "timestamp": "2025-09-18T12:55:15.331596",
      "type": "decision",
      "conversation_id": "",
      "files": "[\"python_hello_world.py\"]",
      "developer_id": "",
      "tags": "[\"python\", \"mcp\", \"server\", \"hello-world\", \"protocol\", \"async\", \"tools\", \"resources\"]"
    }
  },
  {
    "id": "593be2eb-55ab-433b-b7f1-7901ba185f4e",
    "content": "Build smart context injection as the startup killer feature | Developers spend 60-80% of tokens re-establishing context. Smart injection saves tokens and time by automatically providing relevant historical context at session start.",
    "metadata": {
      "conversation_id": "",
      "timestamp": "2025-09-18T14:02:27.938813",
      "type": "decision",
      "files": "[\"context/smart_injector.py\", \"tools/retrieval_tools.py\", \"server.py\"]",
      "developer_id": "",
      "tags": "[\"startup\", \"killer-feature\", \"efficiency\", \"context-injection\"]"
    }
  },
  {
    "id": "70a9af2d-b879-4b31-b02d-09b6bd579fbc",
    "content": "Use ultra-compressed context format for maximum token efficiency | Token efficiency is critical. Use minimal formatting, group by type, compress content to maximize context value per token. Target 60-80% token savings vs manual context.",
    "metadata": {
      "conversation_id": "",
      "files": "[\"context/smart_injector.py\", \"context/compressor.py\"]",
      "type": "decision",
      "tags": "[\"optimization\", \"tokens\", \"efficiency\", \"compression\"]",
      "timestamp": "2025-09-18T14:02:29.618209",
      "developer_id": ""
    }
  },
  {
    "id": "19951e23-f9fb-4776-bf4c-745b406abd6a",
    "content": "Implement automatic session start detection for seamless UX | Context injection should be invisible to developers. Auto-detect new sessions based on time gaps, branch switches, and file patterns. Never interrupt workflow.",
    "metadata": {
      "type": "decision",
      "conversation_id": "",
      "timestamp": "2025-09-18T14:02:29.696697",
      "tags": "[\"automation\", \"user-experience\", \"session-detection\"]",
      "files": "[\"context/smart_injector.py\", \"tools/retrieval_tools.py\"]",
      "developer_id": ""
    }
  },
  {
    "id": "d94de5a0-bc29-4e6a-8251-037575d79e66",
    "content": "Built SmartContextInjector with relevance scoring and token optimization | Implemented multi-step process: 1) relevance scoring with file overlap and recency, 2) token-density optimization, 3) ultra-compressed output format. Fixed MemoryStorage.get_all_memories() method and lowered efficiency thresholds for demo.",
    "metadata": {
      "timestamp": "2025-09-18T14:03:06.679256",
      "type": "decision",
      "conversation_id": "",
      "developer_id": "",
      "files": "[\"context/smart_injector.py\", \"memory/storage.py\", \"tools/retrieval_tools.py\"]",
      "tags": "[\"implementation\", \"technical\", \"relevance-scoring\", \"optimization\"]"
    }
  },
  {
    "id": "0ac62499-2d8d-4f07-8cbc-f32c1f9d1791",
    "content": "Changed auto-recording from time-based to message-count-based context | User requested to change the auto-recording system from using a 5-minute time window to using the last 7 conversation messages for context. This provides more predictable and relevant context association since conversations can have long gaps but still be contextually related.",
    "metadata": {
      "conversation_id": "",
      "type": "decision",
      "files": "[\"memory/auto_trigger.py\"]",
      "developer_id": "",
      "timestamp": "2025-09-18T14:25:56.679173",
      "tags": "[\"auto-recording\", \"context-association\", \"improvement\", \"message-count-based\"]"
    }
  },
  {
    "id": "d6ab6a89-e6d5-4fd7-8127-f6d5e4dad439",
    "content": "Use Docker for Neo4j deployment in development | Docker provides consistent environment, easy setup, and isolation. Alternative was Neo4j Desktop but Docker is more lightweight and CLI-friendly.",
    "metadata": {
      "files": "[\"config.yaml\", \"memory/graph.py\", \"CLAUDE.md\"]",
      "conversation_id": "setup-session-001",
      "timestamp": "2025-09-18T18:16:15.499026",
      "type": "decision",
      "developer_id": "user",
      "tags": "[\"infrastructure\", \"database\", \"docker\", \"neo4j\"]"
    }
  },
  {
    "id": "23010475-4116-41ce-833f-856d03ec8113",
    "content": "Successfully integrated ChromaDB and Neo4j for dual storage | Dual storage gives us both vector similarity search (ChromaDB) and relationship analysis (Neo4j). This enables both semantic and structural understanding of project decisions.",
    "metadata": {
      "timestamp": "2025-09-18T18:17:36.999523",
      "tags": "[\"integration\", \"storage\", \"architecture\", \"success\"]",
      "conversation_id": "integration-test-001",
      "developer_id": "user",
      "type": "decision",
      "files": "[\"memory/storage.py\", \"memory/graph.py\", \"config.yaml\"]"
    }
  }
]