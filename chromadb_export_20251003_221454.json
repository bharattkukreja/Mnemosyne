[
  {
    "id": "5bafda14-ea13-4999-9cd7-eff83075048a",
    "content": "Use React for frontend | React chosen as the frontend framework for the project",
    "metadata": {
      "developer_id": "",
      "conversation_id": "",
      "type": "decision",
      "timestamp": "2025-09-17T19:24:17.539752",
      "files": "[]",
      "tags": "[\"frontend\", \"framework\", \"react\"]"
    }
  },
  {
    "id": "926da1a2-384c-4842-9148-bd81981be4db",
    "content": "Use Rails for frontend work | Changed from React to Rails for frontend development",
    "metadata": {
      "files": "[]",
      "conversation_id": "",
      "type": "decision",
      "tags": "[\"frontend\", \"framework\", \"rails\", \"architecture-change\"]",
      "timestamp": "2025-09-17T19:38:20.286595",
      "developer_id": ""
    }
  },
  {
    "id": "98b096af-ab23-4549-8e9a-6eb67f3d2a45",
    "content": "Created comprehensive Python Hello World examples | Built multiple Hello World implementations in Python to demonstrate different programming paradigms: basic print, functions with parameters, user interaction, and object-oriented approach. This provides a good foundation for Python learning.",
    "metadata": {
      "developer_id": "",
      "conversation_id": "",
      "type": "decision",
      "tags": "[\"python\", \"hello-world\", \"beginner\", \"examples\", \"learning\"]",
      "timestamp": "2025-09-18T11:07:02.902129",
      "files": "[\"python_hello_world.py\"]"
    }
  },
  {
    "id": "8b553b37-17fd-4466-9e4f-c818e9ba4a53",
    "content": "Modified Python example to use \"Foo\" and \"Bar\" instead of \"Hello\" and \"World\" | User requested to rename \"Hello\" to \"Foo\" and \"World\" to \"Bar\" throughout the Python code. Updated all instances including function names, default parameters, comments, and string literals to reflect these changes.",
    "metadata": {
      "timestamp": "2025-09-18T11:07:52.638273",
      "files": "[\"python_hello_world.py\"]",
      "conversation_id": "",
      "tags": "[\"python\", \"modification\", \"foo-bar\", \"refactoring\"]",
      "developer_id": "",
      "type": "decision"
    }
  },
  {
    "id": "0d8ce898-3a01-43f7-9c9e-5a05dac49528",
    "content": "Converted simple Python Hello World into a functional MCP server | Transformed the basic Hello World example into a complete MCP (Model Context Protocol) server implementation. The server includes tools for greetings and stats, resources for server information, and proper async handlers. This provides a practical foundation for building MCP servers.",
    "metadata": {
      "conversation_id": "",
      "developer_id": "",
      "tags": "[\"python\", \"mcp\", \"server\", \"hello-world\", \"protocol\", \"async\", \"tools\", \"resources\"]",
      "timestamp": "2025-09-18T12:55:15.331596",
      "type": "decision",
      "files": "[\"python_hello_world.py\"]"
    }
  },
  {
    "id": "593be2eb-55ab-433b-b7f1-7901ba185f4e",
    "content": "Build smart context injection as the startup killer feature | Developers spend 60-80% of tokens re-establishing context. Smart injection saves tokens and time by automatically providing relevant historical context at session start.",
    "metadata": {
      "files": "[\"context/smart_injector.py\", \"tools/retrieval_tools.py\", \"server.py\"]",
      "type": "decision",
      "conversation_id": "",
      "developer_id": "",
      "timestamp": "2025-09-18T14:02:27.938813",
      "tags": "[\"startup\", \"killer-feature\", \"efficiency\", \"context-injection\"]"
    }
  },
  {
    "id": "70a9af2d-b879-4b31-b02d-09b6bd579fbc",
    "content": "Use ultra-compressed context format for maximum token efficiency | Token efficiency is critical. Use minimal formatting, group by type, compress content to maximize context value per token. Target 60-80% token savings vs manual context.",
    "metadata": {
      "timestamp": "2025-09-18T14:02:29.618209",
      "conversation_id": "",
      "files": "[\"context/smart_injector.py\", \"context/compressor.py\"]",
      "developer_id": "",
      "type": "decision",
      "tags": "[\"optimization\", \"tokens\", \"efficiency\", \"compression\"]"
    }
  },
  {
    "id": "19951e23-f9fb-4776-bf4c-745b406abd6a",
    "content": "Implement automatic session start detection for seamless UX | Context injection should be invisible to developers. Auto-detect new sessions based on time gaps, branch switches, and file patterns. Never interrupt workflow.",
    "metadata": {
      "tags": "[\"automation\", \"user-experience\", \"session-detection\"]",
      "conversation_id": "",
      "timestamp": "2025-09-18T14:02:29.696697",
      "developer_id": "",
      "type": "decision",
      "files": "[\"context/smart_injector.py\", \"tools/retrieval_tools.py\"]"
    }
  },
  {
    "id": "d94de5a0-bc29-4e6a-8251-037575d79e66",
    "content": "Built SmartContextInjector with relevance scoring and token optimization | Implemented multi-step process: 1) relevance scoring with file overlap and recency, 2) token-density optimization, 3) ultra-compressed output format. Fixed MemoryStorage.get_all_memories() method and lowered efficiency thresholds for demo.",
    "metadata": {
      "type": "decision",
      "tags": "[\"implementation\", \"technical\", \"relevance-scoring\", \"optimization\"]",
      "timestamp": "2025-09-18T14:03:06.679256",
      "developer_id": "",
      "conversation_id": "",
      "files": "[\"context/smart_injector.py\", \"memory/storage.py\", \"tools/retrieval_tools.py\"]"
    }
  },
  {
    "id": "0ac62499-2d8d-4f07-8cbc-f32c1f9d1791",
    "content": "Changed auto-recording from time-based to message-count-based context | User requested to change the auto-recording system from using a 5-minute time window to using the last 7 conversation messages for context. This provides more predictable and relevant context association since conversations can have long gaps but still be contextually related.",
    "metadata": {
      "timestamp": "2025-09-18T14:25:56.679173",
      "developer_id": "",
      "type": "decision",
      "tags": "[\"auto-recording\", \"context-association\", \"improvement\", \"message-count-based\"]",
      "files": "[\"memory/auto_trigger.py\"]",
      "conversation_id": ""
    }
  },
  {
    "id": "d6ab6a89-e6d5-4fd7-8127-f6d5e4dad439",
    "content": "Use Docker for Neo4j deployment in development | Docker provides consistent environment, easy setup, and isolation. Alternative was Neo4j Desktop but Docker is more lightweight and CLI-friendly.",
    "metadata": {
      "developer_id": "user",
      "timestamp": "2025-09-18T18:16:15.499026",
      "files": "[\"config.yaml\", \"memory/graph.py\", \"CLAUDE.md\"]",
      "conversation_id": "setup-session-001",
      "tags": "[\"infrastructure\", \"database\", \"docker\", \"neo4j\"]",
      "type": "decision"
    }
  },
  {
    "id": "23010475-4116-41ce-833f-856d03ec8113",
    "content": "Successfully integrated ChromaDB and Neo4j for dual storage | Dual storage gives us both vector similarity search (ChromaDB) and relationship analysis (Neo4j). This enables both semantic and structural understanding of project decisions.",
    "metadata": {
      "conversation_id": "integration-test-001",
      "developer_id": "user",
      "files": "[\"memory/storage.py\", \"memory/graph.py\", \"config.yaml\"]",
      "tags": "[\"integration\", \"storage\", \"architecture\", \"success\"]",
      "type": "decision",
      "timestamp": "2025-09-18T18:17:36.999523"
    }
  },
  {
    "id": "340798f6-d35b-4543-8d5c-e5dfb694bca3",
    "content": "Created hello_world.py and modified it to say 'Hello, Denmark!' instead of 'Hello, World!' | Message 0: user: Create a file hello world in python\n\nMessage 1: assistant: Created hello_world.py with a simple 'Hello, World!' print statement.\n\nMessage 2: user: Modify hello world to actually say hello denmark.\n\nMessage 3: assistant: Modified the hello world file to say 'Hello, Denmark!' instead.",
    "metadata": {
      "tags": "[\"python\", \"edit-create\"]",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello_world.py\", \"hello_world.py\"]",
      "type": "code_context",
      "timestamp": "2025-09-19T20:00:12.013512",
      "developer_id": "",
      "conversation_id": ""
    }
  },
  {
    "id": "36cf23e6-8627-4887-90bd-571b3ad0e1f2",
    "content": "Created a basic Python Hello World script | User requested a simple Hello World example in Python. Created a minimal script with print statement and shebang line for cross-platform compatibility. This serves as a basic template for Python scripting.",
    "metadata": {
      "tags": "[\"python\", \"hello-world\", \"template\", \"basic\"]",
      "developer_id": "",
      "type": "decision",
      "files": "[\"hello_world.py\"]",
      "conversation_id": "",
      "timestamp": "2025-09-23T21:21:31.579788"
    }
  },
  {
    "id": "1eccdffe-d734-4eb0-85dd-dbd31885b6e2",
    "content": "Expanded Python Hello World script to include a Greeter class with enhanced functionality | Enhanced the basic Hello World script to demonstrate object-oriented programming concepts in Python. Added a Greeter class with features including: customizable default names, greeting counter, time-stamped greetings, type hints, proper documentation, and a main function following Python best practices. This serves as a more comprehensive Python template showing class design, method implementation, and proper code organization.",
    "metadata": {
      "files": "[\"hello_world.py\"]",
      "developer_id": "",
      "conversation_id": "",
      "type": "decision",
      "tags": "[\"python\", \"hello-world\", \"oop\", \"class\", \"enhanced\", \"template\", \"best-practices\", \"type-hints\"]",
      "timestamp": "2025-09-23T21:22:41.632328"
    }
  },
  {
    "id": "8958568d-2610-49ee-b2eb-bfa9502ded8d",
    "content": "Updated Python script to use foo/bar terminology instead of hello world | Modified the class-based Python script to use \"foo\" and \"bar\" terminology, which are common placeholder names in programming examples and testing. Changed class name to FooBarGenerator, method names to use 'foo', default name to 'Bar', and updated all related variables and comments. This maintains the same OOP structure and functionality while using more generic programming terminology that's often used in examples and testing scenarios.",
    "metadata": {
      "timestamp": "2025-09-23T21:25:32.700936",
      "developer_id": "",
      "tags": "[\"python\", \"foo-bar\", \"oop\", \"class\", \"template\", \"placeholder\", \"example\", \"type-hints\"]",
      "conversation_id": "",
      "files": "[\"foo_bar.py\"]",
      "type": "decision"
    }
  },
  {
    "id": "0b56bff5-43ee-480b-bd1d-6057d3c75d76",
    "content": "Refactor hello_world.py to use class-based approach | Changed from simple function call to object-oriented design with HelloWorld class for better structure and extensibility",
    "metadata": {
      "developer_id": "",
      "type": "decision",
      "files": "[\"hello_world.py\"]",
      "tags": "[\"refactoring\", \"oop\", \"hello-world\"]",
      "conversation_id": "",
      "timestamp": "2025-09-23T22:46:37.357312"
    }
  },
  {
    "id": "a5458eaf-e0e5-4123-af15-3b9ba04206db",
    "content": "Implement context inference for auto-recording when no explicit conversation messages available | The auto-recording system was failing to capture conversations when no MCP tools were called because it relied solely on explicit conversation message tracking. Added _infer_context_from_changes() method to extract context from file content, git history, and file structure when explicit messages aren't available. This ensures 100% conversation capture regardless of whether MCP tools are used during the conversation.",
    "metadata": {
      "developer_id": "",
      "conversation_id": "",
      "type": "decision",
      "tags": "[\"auto-recording\", \"conversation-capture\", \"context-inference\", \"reliability\"]",
      "timestamp": "2025-09-24T13:59:05.071435",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/auto_trigger.py\"]"
    }
  },
  {
    "id": "9aa3c473-732b-40db-931b-f47f2e22d28d",
    "content": "MCP server auto-recording limitation - only works during active sessions | Discovered that MCP servers only run when actively used by the client (Claude Code). The auto-trigger file watching system stops working between sessions when the server shuts down. This means file changes that happen during conversations are only captured if the server is actively running, creating gaps in automatic recording. Need to implement session-start context capture or persistent background watching.",
    "metadata": {
      "timestamp": "2025-09-24T14:05:19.197687",
      "conversation_id": "",
      "developer_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/auto_trigger.py\"]",
      "tags": "[\"auto-recording\", \"mcp-limitation\", \"session-management\", \"architecture\"]",
      "type": "decision"
    }
  },
  {
    "id": "6fdf6a07-f051-4718-9c6d-a1fe38a8d222",
    "content": "Created comprehensive NanoBanana API example with Gemini integration | Message 0: user: Create a standalone file showing the use of nanobanana api with gemini\n\nMessage 1: assistant: I'll create a standalone file demonstrating how to use the nanobanana API with Gemini\n\nMessage 2: assistant: Created comprehensive example including simple chat, multi-turn conversations, streaming, function calling, and batch processing",
    "metadata": {
      "developer_id": "",
      "tags": "[\"api\", \"testing\", \"python\", \"edit-create\"]",
      "type": "code_context",
      "conversation_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/nanobanana_gemini_example.py\"]",
      "timestamp": "2025-09-24T14:05:42.019775"
    }
  },
  {
    "id": "011bd5a0-c430-45cf-bccf-7b4f7be4cff3",
    "content": "Auto-recording failed due to Python environment mismatch - MCP server needs venv | Discovered the real reason auto-recording wasn't working: the MCP server was running with system Python (/opt/homebrew/bin/python3) instead of the venv Python where watchdog is installed. The server silently falls back to WATCHDOG_AVAILABLE = False when the import fails, disabling all file watching. Need to ensure MCP server configuration points to the venv Python interpreter.",
    "metadata": {
      "timestamp": "2025-09-24T14:30:31.947658",
      "tags": "[\"auto-recording\", \"python-environment\", \"watchdog\", \"mcp-configuration\"]",
      "conversation_id": "",
      "developer_id": "",
      "type": "decision",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/auto_trigger.py\"]"
    }
  },
  {
    "id": "972f2699-3b65-4c9b-bde0-15db7901b295",
    "content": "Added to_dict method to CalculationResult class for serialization | Message 0: user: Can you make a new file which multiplies two numbers using classes\n\nMessage 1: assistant: Created comprehensive multiplication calculator using classes with Multiplier, AdvancedMultiplier, CalculationResult, and MultiplicationTable classes\n\nMessage 2: user: I don't see mnemosyne triggered\n\nMessage 3: assistant: Debugging why auto-recording still not working after config fix, added to_dict method for better serialization",
    "metadata": {
      "type": "code_context",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/multiplication_calculator.py\"]",
      "conversation_id": "",
      "developer_id": "",
      "timestamp": "2025-09-25T12:19:32.786640",
      "tags": "[\"python\", \"edit-modify\"]"
    }
  },
  {
    "id": "52e32192-993a-423f-bd05-581426b07e70",
    "content": "Auto-recording requires MCP server restart to pick up configuration changes | The auto-recording system has multiple issues: 1) Configuration changes (Python environment) only take effect after MCP server restart, 2) Current session still uses old config with system Python where watchdog fails, 3) Logging level was set to WARNING hiding INFO messages from auto-trigger, 4) File watching only works when server is running with correct environment and dependencies. Manual association works fine, showing the storage system is functional.",
    "metadata": {
      "tags": "[\"auto-recording\", \"configuration\", \"mcp-restart\", \"debugging\"]",
      "timestamp": "2025-09-25T12:25:01.865026",
      "files": "[\"/Users/bkukreja/.config/claude-code/mcp.json\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "developer_id": "",
      "conversation_id": "",
      "type": "decision"
    }
  },
  {
    "id": "a6951405-50ab-44b9-8cf4-3dc7b0e8afc8",
    "content": "Created a simple FastAPI example with basic CRUD endpoints | User requested a super simple and short FastAPI file demonstrating basic usage. Chose to include common patterns: root endpoint, path parameters, query parameters, POST endpoint, and health check. Used minimal code while showing FastAPI's key features like automatic type validation and interactive docs.",
    "metadata": {
      "files": "[\"main.py\"]",
      "conversation_id": "",
      "timestamp": "2025-09-25T13:23:45.849318",
      "type": "decision",
      "tags": "[\"fastapi\", \"python\", \"web-api\", \"example\", \"tutorial\"]",
      "developer_id": ""
    }
  },
  {
    "id": "3a05e097-8186-440b-88d6-b1a1ae486092",
    "content": "Added second greeting message to say_hello function | Message 0: user: Modify say_hello to add another greeting\n\nMessage 1: assistant: Added a second greeting message to the say_hello() function. Now it prints both \"Hello, World!\" and \"Welcome to Mnemosyne!\"",
    "metadata": {
      "developer_id": "",
      "timestamp": "2025-09-25T14:22:20.896292",
      "type": "code_context",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.py\"]",
      "tags": "[\"python\", \"edit-modify\"]",
      "conversation_id": ""
    }
  },
  {
    "id": "7afc9d44-45ff-4b18-b9e0-7d409a5f7415",
    "content": "Added mandatory Mnemosyne workflow instructions for automatic decision and file change recording | Message 1: assistant: Excellent idea! Yes, this is exactly the right approach. Let me check if Claude Code has configuration files similar to Cursor's `.cursorrules`\n\nMessage 2: user: Claude is not following cursorrules though, is it?\n\nMessage 3: assistant: You're absolutely right - Claude Code doesn't follow `.cursorrules` like Cursor does. That's a Cursor-specific feature. The solution would be to enhance the existing `CLAUDE.md` file to include instructions that tell Claude to automatically record decisions and file changes using the Mnemosyne MCP tools.\n\nMessage 4: user: Yes add it",
    "metadata": {
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/CLAUDE.md\", \"CLAUDE.md\"]",
      "timestamp": "2025-09-25T14:32:44.143097",
      "type": "code_context",
      "tags": "[\"edit-modify\"]",
      "conversation_id": "",
      "developer_id": ""
    }
  },
  {
    "id": "5c1343cf-b53b-456a-88f5-39b19fd5a034",
    "content": "Refactored hello world to use functions - created say_hello() function and main() function with proper if __name__ == \"__main__\" guard | Message 0: Create a simple and short hello world file in python\n\nMessage 1: Modify hello to use functions",
    "metadata": {
      "developer_id": "",
      "type": "code_context",
      "conversation_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.py\"]",
      "tags": "[\"python\", \"edit-modify\"]",
      "timestamp": "2025-09-25T14:37:15.690379"
    }
  },
  {
    "id": "7fd1fe9b-bdd8-4803-8b1c-3ca703bf9ebc",
    "content": "Use function-based structure for hello world with proper main guard | Refactored simple print statement into functions to follow Python best practices with say_hello() returning the message and main() handling execution, plus proper if __name__ == \"__main__\" guard",
    "metadata": {
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.py\"]",
      "tags": "[\"python\", \"best-practices\", \"refactoring\"]",
      "developer_id": "",
      "type": "decision",
      "conversation_id": "",
      "timestamp": "2025-09-25T14:37:38.278743"
    }
  },
  {
    "id": "c07266cd-96fa-463e-acd4-bbd58282342b",
    "content": "Refactored from functions to class-based approach - created HelloWorld class with say_hello() method | Message 0: Modify hello to use functions\n\nMessage 1: Can you actually use a simple class instead",
    "metadata": {
      "type": "code_context",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.py\"]",
      "conversation_id": "",
      "developer_id": "",
      "tags": "[\"python\", \"edit-modify\"]",
      "timestamp": "2025-09-25T14:38:36.514880"
    }
  },
  {
    "id": "3944f73a-615d-4285-ab76-ccd5fafbbd81",
    "content": "Use class-based approach instead of standalone functions for hello world | User preferred class-based structure over functions, so created HelloWorld class with say_hello() method and instantiate it in main()",
    "metadata": {
      "conversation_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.py\"]",
      "tags": "[\"python\", \"class-based\", \"oop\", \"refactoring\"]",
      "timestamp": "2025-09-25T14:39:14.482884",
      "type": "decision",
      "developer_id": ""
    }
  },
  {
    "id": "7d80b13b-b48f-4454-bfd4-a9b7528208c3",
    "content": "Simplified Mnemosyne workflow to use only store_decision tool | Removed associate_code_context to eliminate duplication - store_decision now handles both architectural decisions and code change decisions",
    "metadata": {
      "type": "decision",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/store_tools.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/CLAUDE.md\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "tags": "[\"simplification\", \"refactoring\", \"workflow\"]",
      "timestamp": "2025-09-25T15:24:35.308050",
      "developer_id": "",
      "conversation_id": ""
    }
  },
  {
    "id": "71d00da6-c38e-403f-aeec-42a53941e493",
    "content": "Created simple TypeScript hello world file | User requested a new super simple and short TypeScript file with hello world - created hello.ts with console.log statement",
    "metadata": {
      "conversation_id": "",
      "timestamp": "2025-09-25T15:25:59.323920",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.ts\"]",
      "type": "decision",
      "tags": "[\"typescript\", \"hello-world\", \"new-file\"]",
      "developer_id": ""
    }
  },
  {
    "id": "20cd76ab-e7b4-4e1e-a503-e407d3746f79",
    "content": "Created hello world file in Ruby | User requested a hello world file in Ruby, created simple Ruby script that prints \"Hello, World!\"",
    "metadata": {
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.rb\"]",
      "type": "decision",
      "developer_id": "",
      "timestamp": "2025-09-25T15:34:14.679475",
      "conversation_id": "",
      "tags": "[\"ruby\", \"hello-world\", \"basic\"]"
    }
  },
  {
    "id": "818e0683-2108-4cc7-a552-9ed515d99a26",
    "content": "CLAUDE.md instructions don't carry over in distributed MCP packages | CLAUDE.md is local development guidance for Claude Code sessions, not part of the distributed package. Automatic recording behavior needs to be programmed into server.py tool implementations",
    "metadata": {
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/CLAUDE.md\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "timestamp": "2025-09-25T15:37:46.790400",
      "conversation_id": "",
      "type": "decision",
      "tags": "[\"distribution\", \"packaging\", \"architecture\"]",
      "developer_id": ""
    }
  },
  {
    "id": "65f76740-cd24-4711-b6fa-248382280730",
    "content": "Created a simple Hello World program in C | User requested a basic C hello world file with standard printf output",
    "metadata": {
      "developer_id": "",
      "timestamp": "2025-09-25T15:50:36.270427",
      "conversation_id": "",
      "tags": "[\"c-programming\", \"hello-world\", \"basic-example\"]",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.c\"]",
      "type": "decision"
    }
  },
  {
    "id": "02c9eb18-7d8f-4e9d-8dab-cb6e234cccc1",
    "content": "Design get_past_context feature to extend existing session tracking system | User wants manual session context retrieval. Existing system has session tracking, ChromaDB, and smart injection. Best approach is to add session linking to memories and create dedicated MCP tool for manual past context retrieval rather than extending get_smart_context.",
    "metadata": {
      "type": "decision",
      "conversation_id": "",
      "developer_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/context/session_tracker.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/retrieval_tools.py\"]",
      "tags": "[\"architecture\", \"session-management\", \"context-retrieval\"]",
      "timestamp": "2025-09-26T15:02:31.472026"
    }
  },
  {
    "id": "91127996-b90d-41c5-beb5-671c7f5441db",
    "content": "Completed implementation of get_past_context feature | Successfully implemented the complete get_past_context feature including: session_id field in memory models, session-based memory retrieval, session summarization logic, new MCP tool, auto-recording session tracking, and server registration. The feature allows users to manually retrieve summaries from their last completed session to continue where they left off, reducing token costs and avoiding context re-establishment.",
    "metadata": {
      "conversation_id": "",
      "developer_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/models.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/storage.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/context/summarizer.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/retrieval_tools.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/auto_trigger.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/store_tools.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "type": "decision",
      "tags": "[\"feature-complete\", \"session-management\", \"context-retrieval\", \"get-past-context\"]",
      "timestamp": "2025-09-26T15:22:30.769449"
    }
  },
  {
    "id": "8e32e25e-d665-4de7-b6c4-b0cdf24a7742",
    "content": "Use explicit session markers instead of time-based detection | Claude Code exposes SessionStart/SessionEnd hooks which are more reliable than inferring from time gaps or file changes",
    "metadata": {
      "type": "decision",
      "timestamp": "2025-09-26T15:29:38.012148",
      "session_id": "34225d3f-25d1-4003-851c-c1ba2a649244",
      "tags": "[\"architecture\", \"session-management\"]",
      "files": "[\"context/session_tracker.py\", \"memory/auto_trigger.py\"]",
      "developer_id": "",
      "conversation_id": ""
    }
  },
  {
    "id": "cbc30d6f-80f5-4382-bd8b-f3240c6af21e",
    "content": "Store session_id in memory models for linking | Adding session_id field to Memory base class allows us to retrieve all memories from a specific session efficiently",
    "metadata": {
      "developer_id": "",
      "conversation_id": "",
      "session_id": "34225d3f-25d1-4003-851c-c1ba2a649244",
      "tags": "[\"database-schema\", \"session-linking\"]",
      "type": "decision",
      "files": "[\"memory/models.py\", \"memory/storage.py\"]",
      "timestamp": "2025-09-26T15:29:38.012161"
    }
  },
  {
    "id": "a9553194-1a1a-4dd7-8eb2-891b87fcf238",
    "content": "Implement manual trigger for get_past_context | User requested manual tool call rather than automatic injection to have control over when context is retrieved",
    "metadata": {
      "developer_id": "",
      "tags": "[\"user-interface\", \"manual-control\"]",
      "session_id": "34225d3f-25d1-4003-851c-c1ba2a649244",
      "type": "decision",
      "timestamp": "2025-09-26T15:29:38.012167",
      "conversation_id": "",
      "files": "[\"tools/retrieval_tools.py\", \"server.py\"]"
    }
  },
  {
    "id": "552682e8-af65-4ad1-9c60-c7b8d0119ee8",
    "content": "Use explicit session markers instead of time-based detection | Claude Code exposes SessionStart/SessionEnd hooks which are more reliable than inferring from time gaps or file changes",
    "metadata": {
      "type": "decision",
      "session_id": "556a546e-78a9-4db5-bffb-9a6569b908bf",
      "conversation_id": "",
      "developer_id": "",
      "files": "[\"context/session_tracker.py\", \"memory/auto_trigger.py\"]",
      "timestamp": "2025-09-26T15:31:26.494616",
      "tags": "[\"architecture\", \"session-management\"]"
    }
  },
  {
    "id": "6586d4a6-a323-420e-be38-b6eed81f3180",
    "content": "Store session_id in memory models for linking | Adding session_id field to Memory base class allows us to retrieve all memories from a specific session efficiently",
    "metadata": {
      "timestamp": "2025-09-26T15:31:26.494629",
      "type": "decision",
      "tags": "[\"database-schema\", \"session-linking\"]",
      "session_id": "556a546e-78a9-4db5-bffb-9a6569b908bf",
      "files": "[\"memory/models.py\", \"memory/storage.py\"]",
      "conversation_id": "",
      "developer_id": ""
    }
  },
  {
    "id": "125db5e9-2d44-4ed9-9f9e-05a8acff94ac",
    "content": "Implement manual trigger for get_past_context | User requested manual tool call rather than automatic injection to have control over when context is retrieved",
    "metadata": {
      "tags": "[\"user-interface\", \"manual-control\"]",
      "session_id": "556a546e-78a9-4db5-bffb-9a6569b908bf",
      "conversation_id": "",
      "files": "[\"tools/retrieval_tools.py\", \"server.py\"]",
      "type": "decision",
      "developer_id": "",
      "timestamp": "2025-09-26T15:31:26.494635"
    }
  },
  {
    "id": "93df9e05-8dcc-452f-8c8e-b39e71d2ea97",
    "content": "Use explicit session markers instead of time-based detection | Claude Code exposes SessionStart/SessionEnd hooks which are more reliable than inferring from time gaps or file changes",
    "metadata": {
      "timestamp": "2025-09-26T15:32:10.901849",
      "type": "decision",
      "developer_id": "",
      "files": "[\"context/session_tracker.py\", \"memory/auto_trigger.py\"]",
      "session_id": "4e515209-44c3-4d79-8e30-9cdade9e285b",
      "tags": "[\"architecture\", \"session-management\"]",
      "conversation_id": ""
    }
  },
  {
    "id": "7d3cf576-2913-490b-b1ed-394e85834789",
    "content": "Store session_id in memory models for linking | Adding session_id field to Memory base class allows us to retrieve all memories from a specific session efficiently",
    "metadata": {
      "session_id": "4e515209-44c3-4d79-8e30-9cdade9e285b",
      "timestamp": "2025-09-26T15:32:10.901861",
      "files": "[\"memory/models.py\", \"memory/storage.py\"]",
      "conversation_id": "",
      "tags": "[\"database-schema\", \"session-linking\"]",
      "developer_id": "",
      "type": "decision"
    }
  },
  {
    "id": "03c7d9c7-3c56-46d6-94e7-6adb786ab693",
    "content": "Implement manual trigger for get_past_context | User requested manual tool call rather than automatic injection to have control over when context is retrieved",
    "metadata": {
      "developer_id": "",
      "timestamp": "2025-09-26T15:32:10.901867",
      "conversation_id": "",
      "tags": "[\"user-interface\", \"manual-control\"]",
      "session_id": "4e515209-44c3-4d79-8e30-9cdade9e285b",
      "files": "[\"tools/retrieval_tools.py\", \"server.py\"]",
      "type": "decision"
    }
  },
  {
    "id": "156ed22c-421d-41d3-a0d4-a1653f53fc8b",
    "content": "Successfully tested get_past_context feature with realistic session simulation | Created comprehensive test demonstrating the full session continuity workflow. The feature correctly retrieves previous session data including decisions, TODOs, files, commits, and provides actionable continuation suggestions. Token-efficient context retrieval working as designed.",
    "metadata": {
      "type": "decision",
      "timestamp": "2025-09-26T15:32:42.389987",
      "developer_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/test_session_scenario.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/retrieval_tools.py\"]",
      "conversation_id": "",
      "tags": "[\"testing\", \"feature-validation\", \"session-continuity\", \"get-past-context\"]"
    }
  },
  {
    "id": "ddcc3a2d-f9ad-47bb-99d6-4f581aaeeb40",
    "content": "Created simple Hello World JavaScript file | User requested a simple and short hello world file in JavaScript",
    "metadata": {
      "session_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.js\"]",
      "developer_id": "",
      "conversation_id": "",
      "timestamp": "2025-09-26T15:35:04.187675",
      "tags": "[\"javascript\", \"hello-world\", \"simple\"]",
      "type": "decision"
    }
  },
  {
    "id": "1645060d-9b3d-4b1b-9655-26226c9511e1",
    "content": "Modified hello.js to use function-based approach | User requested to modify the file to use functions instead of direct console.log",
    "metadata": {
      "session_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.js\"]",
      "tags": "[\"javascript\", \"refactoring\", \"functions\"]",
      "type": "decision",
      "timestamp": "2025-09-26T15:35:27.919051",
      "conversation_id": "",
      "developer_id": ""
    }
  },
  {
    "id": "36acedbf-a94b-44d4-b63e-762891149c24",
    "content": "Fixed get_past_context to use get_last_completed_session instead of get_last_session | The get_past_context tool was incorrectly checking if the current session was active and returning early. It should always fetch the last completed session, ignoring any currently active session. Added get_last_completed_session method that filters for sessions with end_time IS NOT NULL.",
    "metadata": {
      "files": "[\"tools/retrieval_tools.py\", \"context/session_database.py\"]",
      "tags": "[\"bug-fix\", \"session-management\", \"past-context\"]",
      "developer_id": "",
      "timestamp": "2025-09-26T15:39:31.437548",
      "type": "decision",
      "session_id": "",
      "conversation_id": ""
    }
  },
  {
    "id": "48a65d94-8755-431f-9b92-c0d432ebca29",
    "content": "Created hello.c with basic Hello World program | User requested a simple C hello world file for testing purposes",
    "metadata": {
      "tags": "[\"c-programming\", \"hello-world\", \"testing\"]",
      "timestamp": "2025-09-26T19:46:41.219397",
      "session_id": "",
      "conversation_id": "",
      "developer_id": "",
      "type": "decision",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/hello.c\"]"
    }
  },
  {
    "id": "ffb54b61-d2da-475a-8450-fafd5b363559",
    "content": "Simplified get_past_context to directly query ChromaDB instead of using complex session tracking | The original implementation relied on a complex session database system that wasn't working correctly. ChromaDB already contains all the conversation memories sorted by timestamp, so we can directly query the recent memories and present a summary. This removes dependencies on session tracking and makes the feature much more reliable.",
    "metadata": {
      "tags": "[]",
      "conversation_id": "",
      "timestamp": "2025-09-26T19:57:29.972877",
      "files": "[\"tools/retrieval_tools.py\"]",
      "developer_id": "",
      "type": "decision",
      "session_id": ""
    }
  },
  {
    "id": "6a9b5264-853c-4c0a-be30-48efbf3da345",
    "content": "Removed all session tracking infrastructure from Mnemosyne | Session tracking added complexity without being used by the core get_past_context functionality. The system now uses a simpler approach that directly queries ChromaDB for recent memories without session boundaries, making the codebase cleaner and easier to maintain.",
    "metadata": {
      "conversation_id": "",
      "files": "[\"tools/retrieval_tools.py\", \"context/smart_injector.py\", \"memory/auto_trigger.py\", \"config.py\", \"config.yaml\"]",
      "type": "decision",
      "session_id": "",
      "developer_id": "",
      "timestamp": "2025-09-26T20:29:03.175453",
      "tags": "[\"cleanup\", \"architecture\", \"simplification\"]"
    }
  },
  {
    "id": "1961810b-9131-416c-9cae-c34719d5ea0c",
    "content": "Added update_todo_status tool to Mnemosyne MCP server | User requested ability to mark TODOs as completed or obsolete. Implemented complete solution including status field update in models, storage backend methods for both ChromaDB and file storage, tool registration in server.py, and filtering logic in get_past_context to hide completed/obsolete TODOs.",
    "metadata": {
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/models.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/memory/storage.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/store_tools.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/tools/retrieval_tools.py\", \"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "type": "decision",
      "tags": "[\"mcp-tool\", \"todo-management\", \"feature-addition\"]",
      "timestamp": "2025-09-26T20:41:07.474981",
      "developer_id": "",
      "session_id": "",
      "conversation_id": ""
    }
  },
  {
    "id": "0b67630d-8277-4a0d-85b0-764b25ff6c32",
    "content": "Update CLAUDE.md documentation | Document the new get_past_context tool and session workflow",
    "metadata": {
      "tags": "[]",
      "developer_id": "",
      "session_id": "34225d3f-25d1-4003-851c-c1ba2a649244",
      "type": "todo",
      "timestamp": "2025-09-26T15:29:38.012191",
      "conversation_id": "",
      "files": "[\"CLAUDE.md\"]",
      "status": "obsolete"
    }
  },
  {
    "id": "eeb816c3-ef7e-4e01-82d3-9feb93c2c45c",
    "content": "Update CLAUDE.md documentation | Document the new get_past_context tool and session workflow",
    "metadata": {
      "status": "obsolete",
      "conversation_id": "",
      "session_id": "556a546e-78a9-4db5-bffb-9a6569b908bf",
      "tags": "[]",
      "type": "todo",
      "developer_id": "",
      "files": "[\"CLAUDE.md\"]",
      "timestamp": "2025-09-26T15:31:26.494661"
    }
  },
  {
    "id": "ab05b5e4-0586-42f0-b42b-e574fe508cc7",
    "content": "Update CLAUDE.md documentation | Document the new get_past_context tool and session workflow",
    "metadata": {
      "tags": "[]",
      "timestamp": "2025-09-26T15:32:10.901893",
      "type": "todo",
      "status": "obsolete",
      "files": "[\"CLAUDE.md\"]",
      "session_id": "4e515209-44c3-4d79-8e30-9cdade9e285b",
      "developer_id": "",
      "conversation_id": ""
    }
  },
  {
    "id": "c7a07ee1-44fe-4043-9b1b-be895985fdd0",
    "content": "Write tests for get_past_context feature | Need comprehensive tests covering edge cases like no previous session, corrupted data",
    "metadata": {
      "timestamp": "2025-09-26T15:29:38.012185",
      "type": "todo",
      "files": "[\"tests/test_get_past_context.py\"]",
      "status": "obsolete",
      "conversation_id": "",
      "tags": "[]",
      "developer_id": "",
      "session_id": "34225d3f-25d1-4003-851c-c1ba2a649244"
    }
  },
  {
    "id": "324c867f-6438-4c08-afcd-70163494f744",
    "content": "Write tests for get_past_context feature | Need comprehensive tests covering edge cases like no previous session, corrupted data",
    "metadata": {
      "timestamp": "2025-09-26T15:31:26.494655",
      "conversation_id": "",
      "developer_id": "",
      "status": "obsolete",
      "tags": "[]",
      "session_id": "556a546e-78a9-4db5-bffb-9a6569b908bf",
      "type": "todo",
      "files": "[\"tests/test_get_past_context.py\"]"
    }
  },
  {
    "id": "676ece5e-983f-4287-bb6c-c1fd25152516",
    "content": "Write tests for get_past_context feature | Need comprehensive tests covering edge cases like no previous session, corrupted data",
    "metadata": {
      "timestamp": "2025-09-26T15:32:10.901888",
      "files": "[\"tests/test_get_past_context.py\"]",
      "conversation_id": "",
      "type": "todo",
      "developer_id": "",
      "status": "obsolete",
      "session_id": "4e515209-44c3-4d79-8e30-9cdade9e285b",
      "tags": "[]"
    }
  },
  {
    "id": "3bc4614a-f49f-4c1d-98fe-6a2b6841028d",
    "content": "Add error handling for session database failures | Need robust fallbacks when session DB is unavailable or corrupted",
    "metadata": {
      "session_id": "34225d3f-25d1-4003-851c-c1ba2a649244",
      "conversation_id": "",
      "timestamp": "2025-09-26T15:29:38.012177",
      "type": "todo",
      "status": "obsolete",
      "developer_id": "",
      "tags": "[]",
      "files": "[\"context/session_database.py\"]"
    }
  },
  {
    "id": "1c558c2c-6765-4ff8-8e3c-f827eca7d217",
    "content": "Add error handling for session database failures | Need robust fallbacks when session DB is unavailable or corrupted",
    "metadata": {
      "status": "obsolete",
      "tags": "[]",
      "type": "todo",
      "developer_id": "",
      "session_id": "556a546e-78a9-4db5-bffb-9a6569b908bf",
      "files": "[\"context/session_database.py\"]",
      "conversation_id": "",
      "timestamp": "2025-09-26T15:31:26.494643"
    }
  },
  {
    "id": "5faa7605-a79f-436f-b793-7da7b126cc0b",
    "content": "Add error handling for session database failures | Need robust fallbacks when session DB is unavailable or corrupted",
    "metadata": {
      "developer_id": "",
      "timestamp": "2025-09-26T15:32:10.901876",
      "status": "obsolete",
      "tags": "[]",
      "type": "todo",
      "conversation_id": "",
      "session_id": "4e515209-44c3-4d79-8e30-9cdade9e285b",
      "files": "[\"context/session_database.py\"]"
    }
  },
  {
    "id": "3e8d8f18-e279-4624-a204-91fd043f38c6",
    "content": "Added connection confirmation message to Mnemosyne MCP server | User noticed the MCP server takes 10-15 seconds to connect and wanted visual confirmation when it's ready. Added both logger and print statements to provide immediate feedback when the stdio connection is established, which indicates the MCP server is fully connected and ready to accept tool calls.",
    "metadata": {
      "tags": "[\"mcp\", \"connection\", \"user-experience\", \"logging\"]",
      "developer_id": "",
      "session_id": "",
      "conversation_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "type": "decision",
      "timestamp": "2025-09-26T20:48:18.614246"
    }
  },
  {
    "id": "6ae4113c-1e07-4ff6-9a3c-eb63217e9a9b",
    "content": "Fixed MCP server confirmation message placement | The confirmation message was printing inside the stdio_server context, which interferes with MCP protocol communication. Moved the print statement before the stdio streams are taken over by MCP.",
    "metadata": {
      "developer_id": "",
      "files": "[\"/Users/bkukreja/Desktop/Projects/Mnemosyne/server.py\"]",
      "tags": "[\"bugfix\", \"mcp\", \"server\", \"stdio\"]",
      "timestamp": "2025-09-26T20:51:22.700249",
      "conversation_id": "",
      "session_id": "",
      "type": "decision"
    }
  }
]